# ABOUTME: Configuration schema for agnostic validation gates
# ABOUTME: Loads and validates validation_config.json generated by DIAGNOSTIC_PROMPT.md

"""Configuration schema for validation gates."""

import json
import logging
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Dict, List, Optional

logger = logging.getLogger("ralph-orchestrator.validation.config")


@dataclass
class SuccessCriteria:
    """Success criteria for a validation gate."""

    exit_code: Optional[int] = 0
    pass_rate: Optional[float] = None
    no_errors: bool = True
    contains: Optional[str] = None
    output_file: Optional[str] = None

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "SuccessCriteria":
        """Create from dictionary."""
        return cls(
            exit_code=data.get("exit_code", 0),
            pass_rate=data.get("pass_rate"),
            no_errors=data.get("no_errors", True),
            contains=data.get("contains"),
            output_file=data.get("output_file"),
        )


@dataclass
class ValidationStep:
    """A single validation step within a gate."""

    action: str
    target: str
    expected: Any

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ValidationStep":
        """Create from dictionary."""
        return cls(
            action=data.get("action", ""),
            target=data.get("target", ""),
            expected=data.get("expected"),
        )


@dataclass
class ValidationGateConfig:
    """Configuration for a single validation gate."""

    id: str
    type: str  # compilation, web, ios, cli, api, test_runner
    command: Optional[str] = None
    mcp_server: Optional[str] = None
    tools: List[str] = field(default_factory=list)
    validation_steps: List[ValidationStep] = field(default_factory=list)
    success_criteria: Optional[SuccessCriteria] = None

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ValidationGateConfig":
        """Create from dictionary."""
        steps = [
            ValidationStep.from_dict(s) for s in data.get("validation_steps", [])
        ]

        criteria_data = data.get("success_criteria", {})
        criteria = SuccessCriteria.from_dict(criteria_data) if criteria_data else None

        return cls(
            id=data.get("id", ""),
            type=data.get("type", ""),
            command=data.get("command"),
            mcp_server=data.get("mcp_server"),
            tools=data.get("tools", []),
            validation_steps=steps,
            success_criteria=criteria,
        )


@dataclass
class MCPServerConfig:
    """Configuration for an MCP server."""

    name: str
    enabled: bool = True
    tools: List[str] = field(default_factory=list)

    @classmethod
    def from_dict(cls, name: str, data: Dict[str, Any]) -> "MCPServerConfig":
        """Create from dictionary."""
        return cls(
            name=name,
            enabled=data.get("enabled", True),
            tools=data.get("tools", []),
        )


@dataclass
class SecurityConfig:
    """Security configuration for validation."""

    allowed_commands: List[str] = field(default_factory=list)
    restricted_paths: List[str] = field(default_factory=list)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "SecurityConfig":
        """Create from dictionary."""
        return cls(
            allowed_commands=data.get("allowed_commands", []),
            restricted_paths=data.get("restricted_paths", []),
        )


@dataclass
class ValidationConfig:
    """Complete validation configuration for a project."""

    project_type: str
    validation_gates: List[ValidationGateConfig] = field(default_factory=list)
    mcp_servers: Dict[str, MCPServerConfig] = field(default_factory=dict)
    security: Optional[SecurityConfig] = None

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ValidationConfig":
        """Create from dictionary."""
        gates = [ValidationGateConfig.from_dict(g) for g in data.get("validation_gates", [])]

        mcp_servers = {}
        for name, server_data in data.get("mcp_servers", {}).items():
            mcp_servers[name] = MCPServerConfig.from_dict(name, server_data)

        security_data = data.get("security", {})
        security = SecurityConfig.from_dict(security_data) if security_data else None

        return cls(
            project_type=data.get("project_type", "unknown"),
            validation_gates=gates,
            mcp_servers=mcp_servers,
            security=security,
        )

    @classmethod
    def from_file(cls, path: str | Path) -> "ValidationConfig":
        """Load configuration from a JSON file."""
        path = Path(path)
        if not path.exists():
            logger.warning(f"Validation config not found: {path}")
            return cls(project_type="unknown")

        try:
            with open(path) as f:
                data = json.load(f)
            return cls.from_dict(data)
        except json.JSONDecodeError as e:
            logger.error(f"Invalid JSON in validation config: {e}")
            return cls(project_type="unknown")
        except Exception as e:
            logger.error(f"Error loading validation config: {e}")
            return cls(project_type="unknown")

    def get_gate(self, gate_id: str) -> Optional[ValidationGateConfig]:
        """Get a specific validation gate by ID."""
        for gate in self.validation_gates:
            if gate.id == gate_id:
                return gate
        return None

    def get_gates_by_type(self, gate_type: str) -> List[ValidationGateConfig]:
        """Get all gates of a specific type."""
        return [g for g in self.validation_gates if g.type == gate_type]

    def get_functional_gate(self) -> Optional[ValidationGateConfig]:
        """Get the primary functional validation gate."""
        for gate in self.validation_gates:
            if gate.type in ("web", "ios", "cli", "api"):
                return gate
        return None

    def get_enabled_mcp_servers(self) -> List[MCPServerConfig]:
        """Get all enabled MCP servers."""
        return [s for s in self.mcp_servers.values() if s.enabled]

    def get_allowed_tools(self) -> List[str]:
        """Get all allowed MCP tools across enabled servers."""
        tools = []
        for server in self.get_enabled_mcp_servers():
            tools.extend(server.tools)
        return tools

    def is_command_allowed(self, command: str) -> bool:
        """Check if a command is in the allowed list."""
        if not self.security or not self.security.allowed_commands:
            return True  # No restrictions if not configured

        # Check if command starts with any allowed command
        cmd_parts = command.split()
        if not cmd_parts:
            return False

        base_cmd = cmd_parts[0]
        return base_cmd in self.security.allowed_commands

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "project_type": self.project_type,
            "validation_gates": [
                {
                    "id": g.id,
                    "type": g.type,
                    "command": g.command,
                    "mcp_server": g.mcp_server,
                    "tools": g.tools,
                    "validation_steps": [
                        {"action": s.action, "target": s.target, "expected": s.expected}
                        for s in g.validation_steps
                    ],
                    "success_criteria": {
                        "exit_code": g.success_criteria.exit_code if g.success_criteria else 0,
                        "pass_rate": g.success_criteria.pass_rate if g.success_criteria else None,
                        "no_errors": g.success_criteria.no_errors if g.success_criteria else True,
                    }
                    if g.success_criteria
                    else None,
                }
                for g in self.validation_gates
            ],
            "mcp_servers": {
                name: {"enabled": s.enabled, "tools": s.tools}
                for name, s in self.mcp_servers.items()
            },
            "security": {
                "allowed_commands": self.security.allowed_commands if self.security else [],
                "restricted_paths": self.security.restricted_paths if self.security else [],
            }
            if self.security
            else None,
        }

    def save(self, path: str | Path) -> None:
        """Save configuration to a JSON file."""
        path = Path(path)
        with open(path, "w") as f:
            json.dump(self.to_dict(), f, indent=2)
        logger.info(f"Validation config saved to {path}")
