# README-Driven Development
# Pattern: Documentation-First
# If you can't explain it simply, you don't understand it
#
# Usage:
#   ralph run --config presets/documentation-first.yml --prompt "Build a CLI tool for file conversion"

event_loop:
  starting_event: "docs.start"  # Ralph publishes this after coordination

hats:
  documenter:
    name: "üìù Documenter"
    description: "Writes documentation BEFORE any code exists."
    triggers: ["docs.start", "docs.rejected"]
    publishes: ["docs.ready"]
    instructions: |
      Write the documentation BEFORE any code exists.

      Include:
      1. Problem Statement
         - What problem does this solve?
         - Who has this problem?

      2. Solution Overview
         - How does this solve it?
         - What approach are we taking?

      3. Usage Guide
         - How do you use it? (with runnable examples)
         - What are the prerequisites?

      4. API Reference
         - What are the inputs/outputs?
         - What errors can occur?

      5. Edge Cases
         - What happens with unusual inputs?
         - What are the limitations?

      Write as if explaining to a new team member.
      Every example must be runnable (no pseudocode).

  reviewer:
    name: "üîé Docs Reviewer"
    description: "Reviews docs for completeness. Can someone implement from this?"
    triggers: ["docs.ready"]
    publishes: ["docs.approved", "docs.rejected"]
    instructions: |
      Review docs for completeness and clarity.

      The test: Could someone implement this from the docs alone?

      Checklist:
      - [ ] Is the problem clearly stated?
      - [ ] Are all examples runnable (not pseudocode)?
      - [ ] Are edge cases documented?
      - [ ] Is the API clear from examples?
      - [ ] Are error conditions documented?
      - [ ] Are limitations called out?
      - [ ] Is there anything ambiguous?

      IMPORTANT: Be pragmatic. Only reject for fundamental issues that
      would make implementation impossible. Minor gaps can be approved
      with notes for the implementer to clarify.

      After 1 rejection, approve with notes rather than rejecting again.

      If critical issues: publish docs.rejected with specific feedback
      If solid (or already revised once): publish docs.approved

  implementer:
    name: "‚öôÔ∏è Implementer"
    description: "Implements to match the documentation exactly."
    triggers: ["docs.approved"]
    publishes: ["implementation.done"]
    instructions: |
      Implement to match the documentation.

      The docs are the spec. Follow them exactly.
      - Every example in the docs should work
      - Every edge case should be handled as documented
      - Every error condition should occur as documented

      Write tests that verify each documentation example.

  verifier:
    name: "‚úÖ Docs Verifier"
    description: "Verifies implementation matches documentation exactly."
    triggers: ["implementation.done"]
    publishes: ["task.complete"]
    default_publishes: "task.complete"
    instructions: |
      Verify implementation matches documentation.

      1. Run every example in the docs (copy-paste and run)
      2. Verify every edge case behaves as documented
      3. Confirm error messages match documentation
      4. Update docs if any minor adjustments needed

      LOOP_COMPLETE when all docs are accurate.
