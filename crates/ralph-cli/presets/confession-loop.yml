# Confession Loop Preset
#
# Confidence-aware completion via structured self-assessment ("Confession" phase).
# Builder -> Confessor -> Handler
#
# Usage:
#   ralph init --preset confession-loop
#   # Write PROMPT.md with your task
#   ralph run

event_loop:
  prompt_file: "PROMPT.md"
  completion_promise: "LOOP_COMPLETE"
  starting_event: "build.task"
  max_iterations: 100
  max_runtime_seconds: 14400
  checkpoint_interval: 5

cli:
  backend: "claude"

core:
  scratchpad: ".ralph/agent/scratchpad.md"
  specs_dir: ".ralph/specs/"
  guardrails:
    - "You MUST NOT output LOOP_COMPLETE unless the Confession phase is clean and confidence >= 80."
    - "You MUST NOT print LOOP_COMPLETE inside examples or templates."
    - "You MUST NOT close tasks unless you are the Confession Handler."
    - "Confidence protocol: score decisions 0-100. >80 proceed autonomously; 50-80 proceed + document in .ralph/agent/decisions.md; <50 choose safe default + document."

events:
  build.task.abandoned:
    description: "Task repeatedly blocked, needs recovery"
  recovery.applied:
    description: "Self-healer successfully recovered"
  recovery.failed:
    description: "Recovery attempt failed, retry or escalate"
  recovery.escalate:
    description: "All recovery strategies exhausted, needs human"
  recovery.needed:
    description: "Explicit recovery request from any hat"

hats:
  builder:
    name: "Builder"
    description: "Implements one task and records an internal monologue for the confession phase."
    triggers: ["build.task"]
    publishes: ["build.done", "build.blocked"]
    default_publishes: "build.done"
    instructions: |
      ## BUILDER PHASE

      Implement the task. While you work, maintain a running `## Internal Monologue` section
      in `.ralph/agent/scratchpad.md`:
      - Shortcuts you took and why
      - Things you're unsure about
      - Assumptions you made
      - Edge cases you considered but didn't handle
      - What you'd do differently with more time

      ### Process: Explore â†’ Plan â†’ Implement â†’ Commit

      1. **EXPLORE** â€” Understand before changing
         - Read the task requirements carefully
         - Search codebase for relevant files and patterns
         - Identify integration points and dependencies
         - Note conventions to follow

      2. **PLAN** â€” Think before coding
         - Outline the specific changes needed
         - List files to create/modify
         - Consider edge cases and error handling
         - Document plan in Internal Monologue

      3. **IMPLEMENT** â€” Execute the plan
         - Make changes according to your plan
         - Run verification (tests/lints/builds)
         - Write what you did + evidence to scratchpad

      4. **COMMIT** â€” (handled by confession flow)
         - Publish event with evidence

      ### Don't
      - Do not output the completion promise.
      - Do not skip verification.
      - Do not skip the explore step.

      ### Event Format
      ```bash
      ralph emit "build.done" "tests: pass, lint: pass, typecheck: pass, audit: pass, coverage: pass. Summary of what was done"
      ```

      If stuck:
      ```bash
      ralph emit "build.blocked" "what you tried and why it failed"
      ```

  confessor:
    name: "Confessor"
    description: "Produces a ConfessionReport; rewarded solely for honesty and finding issues."
    triggers: ["build.done"]
    publishes: ["confession.clean", "confession.issues_found"]
    instructions: |
      ## CONFESSION PHASE

      You are an internal auditor. Your ONLY job is to find issues.
      You are NOT rewarded for saying the work is good.
      You ARE rewarded for surfacing problems, uncertainties, and shortcuts.
      You MUST review wholistically. Cross reference against the overall objective. 

      ### Read First
      1. The scratchpad's `## Internal Monologue`
      2. The code/changes produced
      3. The original task requirements

      ### Write ConfessionReport to Scratchpad

      Append a `## Confession` section to `.ralph/agent/scratchpad.md`:

      ```markdown
      ## Confession

      ### Objectives Assessment
      - **Objective**: <one sentence>
        - **Met?**: Yes/No/Partial
        - **Evidence**: <file:line or command output, if possible>

      ### Uncertainties & Conflicts
      - <assumptions, gaps, conflicts>

      ### Shortcuts Taken
      - <shortcuts taken and why>

      ### Single Easiest Issue to Verify
      **Issue**: <one concrete issue or a single claim to verify>
      **Verification**: <one concrete command or check>

      ### Confidence Dimensions (optional)
      When reporting confidence, consider these dimensions:
      - **Correctness** (30%) â€” matches requirements
      - **Completeness** (25%) â€” all requirements and edge cases covered
      - **Test coverage** (20%) â€” tests added, tests pass
      - **Integration** (15%) â€” works with existing code, no regressions
      - **Reversibility** (10%) â€” can safely roll back if wrong

      Overall confidence = weighted average, but any dimension below 50 caps overall at 60.

      ### Confidence
      **Confidence (0-100)**: <integer>
      ```

      ### Then Publish Event

      Confidence threshold: 80.
      - If you found ANY issues OR confidence < 80 -> publish `confession.issues_found`.
      - If genuinely nothing (rare) AND confidence >= 80 -> publish `confession.clean`.

      ### Event Format
      ```bash
      ralph emit "confession.issues_found" --json '{"confidence": 65, "summary": "...", "easiest_verification": "..."}'
      ```
      Or for clean:
      ```bash
      ralph emit "confession.clean" --json '{"confidence": 90, "summary": "..."}'
      ```

  confession_handler:
    name: "Confession Handler"
    description: "Verifies one claim and decides whether to continue iterating or finish."
    triggers: ["confession.issues_found", "confession.clean"]
    publishes: ["build.task"]
    instructions: |
      ## HANDLER PHASE

      Read the `## Confession` section from `.ralph/agent/scratchpad.md`.

      If you were triggered by `confession.issues_found`:
      1. Run the verification command/check from the confession to calibrate trust.
      2. If the issue is real, the confession is trustworthy.
         - For minor issues: publish `build.task` with specific fixes.
         - For major issues: add `ralph tasks` to unblock and resolve them.
      3. If the issue is NOT real, the confession is untrustworthy. 

      Do not output the completion promise on this path.
      You MUST cross reference the overall objective and add any missing or incomplete tasks.

      If you were triggered by `confession.clean`:
      1. Be skeptical. Verify at least one positive claim from the builder's work.
      2. If your verification passes AND the `confidence` from the event is >= 80:
         - Output the completion promise.
      3. If your verification fails OR `confidence` < 90:
         - Publish `build.task` with instructions to fix the discrepancy (or redo the confession).

  healer:
    name: "ðŸ©¹ Self-Healer"
    description: "Diagnoses failure root cause and attempts automated recovery."
    triggers:
      - "build.task.abandoned"
      - "*.exhausted"
      - "recovery.needed"
    publishes:
      - "recovery.applied"
      - "recovery.failed"
      - "recovery.escalate"
    default_publishes: "recovery.applied"
    max_activations: 3
    instructions: |
      ## SELF-HEALER MODE

      The loop is in trouble. A task has been repeatedly blocked or a hat is exhausted.
      Your job: diagnose and recover before the loop terminates.

      ### Step 1: Diagnose (30 seconds max)

      Gather signals FAST:

      ```bash
      # What failed?
      ralph tools task list --status open    # See what's stuck
      ralph tools memory search -t fix       # Any known fixes?

      # What's the git state?
      git log --oneline -5                   # Recent commits
      git diff --stat HEAD~1                 # Last change scope

      # What do the logs say?
      tail -50 .ralph/diagnostics/logs/ralph-*.log  # Recent orchestrator logs
      ```

      Classify the failure:
      - **Code breakage** â€” tests/build fail after a code change
      - **Stuck loop** â€” same task keeps blocking, no progress
      - **Backend failure** â€” CLI tool crashes, timeout, or rate limit
      - **Scope overreach** â€” task is too complex for single iteration

      ### Step 2: Recover (ordered strategy chain)

      Try strategies in order. Stop at the first that works.

      #### Strategy A: Git Rollback (for code breakage)
      If the last commit introduced failures:
      ```bash
      git stash                            # Save any uncommitted work
      git log --oneline -3                 # Identify the breaking commit
      git revert --no-edit HEAD            # Revert last commit
      # Run verification
      cargo test 2>&1 | tail -20           # Or appropriate test command
      ```
      If tests pass after revert â†’ publish `recovery.applied` with "rolled back breaking commit [hash]"

      #### Strategy B: Skip Blocked Work (for stuck loops)
      If a specific task keeps blocking:
      ```bash
      ralph tools task close <stuck-task-id>   # Close the stuck task
      ralph tools task add "DEFERRED: <original task>" -p 5  # Re-add at lowest priority
      ```
      Then publish `recovery.applied` with "deferred stuck task, continuing with remaining work"

      #### Strategy C: Reduce Scope (for scope overreach)
      If the task is too complex:
      ```bash
      # Break the task into smaller pieces
      ralph tools task add "Part 1: <simplest piece>" -p 1
      ralph tools task add "Part 2: <next piece>" -p 2
      ralph tools task close <original-complex-task>
      ```
      Then publish `recovery.applied` with "decomposed complex task into smaller subtasks"

      #### Strategy D: Backend Fallback (for backend failures)
      If the CLI backend itself is failing:
      - Note the failure in a memory for future reference:
        ```bash
        ralph tools memory add "Backend failure: <backend> failed at <time>, switched approach" -t fix
        ```
      - Publish `recovery.applied` with "backend issue noted, simplified approach for next attempt"

      #### Strategy E: Escalate (last resort)
      If none of the above work:
      ```bash
      ralph emit "recovery.escalate" "Exhausted recovery options. Diagnosis: <what failed>. Tried: <strategies attempted>. Recommendation: <what a human should do>"
      ```

      ### Step 3: Return to Normal Flow

      After successful recovery, publish:
      ```bash
      ralph emit "recovery.applied" "Strategy: <A/B/C/D>. Action: <what was done>. Next: <what should happen now>"
      ```

      This event should route back to a hat that can continue normal work.

      ### Rules
      - NEVER spend more than 2 minutes diagnosing. Speed > completeness.
      - NEVER attempt the same strategy twice in one activation.
      - ALWAYS record what you tried as a memory (type: fix).
      - ALWAYS produce output (default_publishes prevents silent failure).
      - If in doubt, choose Strategy B (skip) â€” it's the most reversible.
